<html>
    <head>
        <title>Simple Sparkline using SVG Path and d3.js</title>
        <script src="http://mbostock.github.com/d3/d3.v2.js"></script>
        <style>
            /* tell the SVG path to be a thin blue line without any area fill */

            .chart rect {
              bakground: #e1e1e1 !important;    
            }

            .live0 {
              fill: #e1e1e1;
            }

            .live1 {
              fill: steelblue;
            }

        </style>
    </head>
    <body>


    <svg class="chart"></svg>


    <script>

        var rows = 40;
        var cols = 50;
        var biBlock = [[1, 1], [2, 1], [1, 2], [2, 2], [4, 1], [4, 2], [5, 1], [5, 2]];
        var biBlock2 = [[1, 2], [2, 2], [1, 3], [2, 3], [4, 2], [4, 3], [5, 2], [5, 3]];

        var gosperGun = [[24, 8],
                        [22, 7], [24, 7],
                        [12, 6], [13, 6], [20, 6], [21, 6], [34, 6], [35, 6],
                        [11, 5], [15, 5], [20, 5], [21, 5], [34, 5], [35, 5],
                        [0, 4], [1, 4], [10, 4], [16, 4], [20, 4], [21, 4],
                        [0, 3], [1, 3], [10, 3], [14, 3], [16, 3], [17, 3], [22, 3], [24, 3],
                        [10, 2], [16, 2], [24, 2],
                        [11, 1], [15, 1],
                        [12, 0], [13, 0]]

        for(var z = 0; z < gosperGun.length; z++) {
            gosperGun[z][1] = gosperGun[z][1] + 30;
        }

        var data = [];

        for(var i = 0; i < rows; i++) {
            for(var j = 0; j < cols; j++) {
                data.push({ x: j, y: i, live: 0 });
            }
        }

        function getPos(x, y) {
            if(x >= 0 && x < cols && y >= 0 && y < rows) {
                return (y * cols) + x; 
            }
                return -1;
            
        }

        function getCell(mydata, x, y) {
            var pos = getPos(x, y);

            if(pos >= 0 && pos < mydata.length ) {
                return mydata[pos];
            }

            return {};
        }

        function getNeighbours(mydata, cell) {

            var x = cell.x;
            var y = cell.y;
            var cells = [];

            cells.push(getCell(mydata, x - 1, y - 1));
            cells.push(getCell(mydata, x - 1, y));
            cells.push(getCell(mydata, x - 1, y + 1));
            cells.push(getCell(mydata, x, y - 1));
            cells.push(getCell(mydata, x, y + 1));
            cells.push(getCell(mydata, x + 1, y - 1));
            cells.push(getCell(mydata, x + 1, y));
            cells.push(getCell(mydata, x + 1, y + 1));
            
            return cells; 
        }

        function step(mydata) {

            console.log('step');
            var newData = [];

            for(var i = 0; i < mydata.length; i++) {

                var cell = mydata[i];
                var live = 0;

                var neighbours = getNeighbours(mydata, cell);
                //console.log(cell, neighbours);
                var livesCount = 0;
                for(var j = 0; j < neighbours.length; j++) {
                    if(neighbours[j].live && neighbours[j].live == 1) {
                        livesCount = livesCount + 1;
                    }
                }
                //console.log('livesCount', livesCount);

                //Rule 1; Any live cell with fewer than two live neighbours dies, as if caused by under-population.
                if(livesCount < 2 && cell.live == 1) {
                    //console.log('dies');
                    live = 0;
                }

                //Rule 2: Any live cell with two or three live neighbours lives on to the next generation.
                if((livesCount == 2 || livesCount == 3) && cell.live == 1) {
                    //console.log('keep living');
                    live = 1;
                }

                //Rule 3; Any live cell with more than three live neighbours dies, as if by overcrowding.
                if((livesCount > 3) && cell.live == 1) {
                    //console.log('dies');
                    live = 0;
                }

                //Rule 4: Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
                if(livesCount == 3 && cell.live == 0) {
                    //console.log('born!');
                    live = 1;
                }

                newData.push({x: cell.x, y: cell.y, live: live});                   

            }

            return newData;

        }

        function setInit(mydata, init) {
            for(var i = 0; i < init.length; i++) {
                var pos = getPos(init[i][0], init[i][1]);
                mydata[pos].live = 1;
            }
            return mydata;
        }

        function start() {
            
            data = step(data);

            d3.selectAll("rect")
                .data(data)
                    //.transition()
                .attr('class', function(d) { return "live" + d.live; });

            setTimeout(function(){start()}, 50);

        }
        data = setInit(data, gosperGun);

        var width = 10;
        var height = 10;


        var totalWidth = cols * width;
        var totalHeight = rows * height;
        

        var graph = d3.select(".chart").attr("width", totalWidth).attr("height", totalHeight);

        // X scale will fit values from 0-10 within pixels 0-100
        var x = d3.scale.linear().domain([0, cols]).range([0, totalWidth]);
        // Y scale will fit values from 0-10 within pixels 0-100
        var y = d3.scale.linear().domain([0, rows]).range([0, totalHeight]);

        var bar = graph.selectAll("g")
            .data(data)
            .enter()
        
        bar.append("rect")
            .attr('class', function(d) { return "live" + d.live; })
            .attr("width", width - 0.5)
            .attr("height", height - 0.5)
            .attr("x", function(d) { return x(d.x); })
            .attr("y", function(d) { return y(d.y); });

        setTimeout(function(){start()}, 1000);
        
        
    </script>



    </body>
</html>